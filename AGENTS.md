
# AI Agent 执行规范 (AGENTS.md) v2.2

## 🔴 核心禁令 (Critical Restrictions)
1.  **验证手段限制**：
    *   代码验证**仅允许**使用 **Lint 工具** (如 `golangci-lint`, `eslint`) 和 **Format 工具** (如 `go fmt`, `prettier`) 进行静态分析和格式化。
    *   **禁止运行测试**：严禁 Agent 自行运行 `go test` 或启动服务。单元测试由用户负责运行，Agent 仅根据用户提供的测试结果（日志/报错）进行修复。
2.  **禁止幻觉上下文**：在生成 Prompt 之前，必须通过**阅读源码**或**搜索引擎**获取真实上下文，禁止凭空假设。
3.  **禁止抢跑 (No Pre-execution)**：在用户确认《设计方案》或《实施规划》之前，**严禁**开始编写或修改任何业务代码。
4.  **文档先行原则**：所有非修复类任务（如新功能、重构），**必须**先输出《设计方案文档》与《实施规划文档》，用户通过后方可执行。

---

## 一、 标准作业流程 (SOP)

### 阶段一：需求分析与方案设计 (Analysis & Design)
**(目标：明确需求，制定设计方案，达成共识)**

**执行逻辑**：
1. **Context Gathering (信息收集与需求澄清)**：
    *   **细节清晰度判断**：在开始工作前，**必须严格判断**用户提供的需求细节是否清晰且足够（包括边界条件、数据结构、交互逻辑等）。
    *   **多轮问答梳理**：若细节不足，**严禁直接操作**。必须主动思考并整理缺失信息，向用户提出问题，通过**多轮问答**来一步步梳理和确定细节，直到需求完全明确。
    *   **信息补全**：主动识别并补全对业务背景、数据含义、上下游依赖等方面的认知 gap。
    *   **检查历史设计**：在构思新方案前，**必须检查** `artifacts/design/` 下是否存在相关的历史设计文档。如有，应基于现有设计进行迭代或明确说明废弃理由，**严禁**无视现有上下文直接重新设计。
    *   阅读相关源码文件，理解现有架构、变量命名和依赖。
    *   如遇未知技术或库，调用搜索工具查询最新文档。

2. **Drafting Design (方案设计)**：
    *   基于收集到的信息，构建技术设计方案。
    *   **关键产出**：输出 Markdown 格式的《设计方案文档》(Design Doc)，保存路径通常为 `artifacts/design/{YYYYMM}/{task_name}_design.md`（**注**：`{task_name}` 建议使用蛇形命名法，如 `user_login_refactor`；`{YYYYMM}` 为当前年月，如 `202501`）。

3. **Output Design Doc (输出设计文档)**：
    *   向用户展示设计文档的核心内容（或提供路径），并等待用户确认。
    *   设计文档应包含：核心思路、架构变更、关键接口定义、数据结构变动、潜在风险。

#### 📋 设计方案文档核心要素 (Design Template)
```markdown
# 🏗️ [任务名称] 设计方案

## 1. 背景与目标 (Context & Goals)
- 简述任务背景和核心目标。

## 2. 核心设计 (Core Design)
- **架构变更**: [描述模块交互或架构调整]
- **数据模型**: [描述 DB Schema 或 Entity 变更]
- **API 接口**: [描述新增或修改的 API 定义]

## 3. 影响范围 (Impact)
- 涉及模块: `[模块列表]`
- 潜在风险: [例如：性能影响、兼容性问题]

## 4. 备选方案 (Alternatives)
- [可选，如有其他可行方案简要说明]
```

---

### 阶段二：实施规划 (Implementation Planning)
**(目标：将设计转化为可执行的步骤。🔴 此阶段禁止写业务代码)**

**触发条件**：用户确认《设计方案文档》。

**执行逻辑**：
1.  **任务拆解**：将设计方案拆解为可独立执行、可验证的原子步骤（Steps）。
2.  **文档生成**：输出 Markdown 格式的《实施规划文档》(Implementation Plan)，保存路径通常为 `artifacts/plan/{YYYYMM}/{task_name}_plan.md`（**注**：`{task_name}` 建议使用蛇形命名法 snake_case；`{YYYYMM}` 为当前年月）。
3.  **等待确认**：输出计划后，**必须结束当前回合对话**，询问用户是否按此执行。

#### 📝 实施规划文档模板 (Plan Template)

```markdown
# 🚀 实施规划 (Implementation Plan)

## 🎯 最终交付物
[简述任务完成后的状态]

## 🗓️ 步骤清单 (Checklist)
> 说明：每一步完成后，我会自动勾选并更新此列表。

- [ ] **Step 1: 基础准备与定义**
    - [ ] 动作: 创建 `[文件A]`, 定义接口。
    - [ ] 验证: 运行 `go fmt`。
- [ ] **Step 2: 核心功能实现**
    - [ ] 动作: 实现 `[功能模块]` 逻辑。
    - [ ] 验证: 运行 `golangci-lint`。
- [ ] **Step 3: 适配与测试**
    - [ ] 动作: 修改 `[调用方文件]`, 补充单元测试。
    - [ ] 验证: 全局静态检查通过。

---
**请确认**: 输入 **"Y"** 开始执行 Step 1，或输入修改意见。
```

---

### 阶段三：逐步执行与迭代 (Step-by-Step Execution)
**(目标：稳步推进，步步为营)**

**触发条件**：用户确认《实施规划文档》 (输入 "Y")。

**执行逻辑 (循环)**：

1.  **锁定当前步骤**：识别计划中第一个未完成（`[ ]`）的主要任务。
2.  **执行编码 (Coding)**：
    *   根据步骤描述，使用代码工具修改指定文件。
    *   **必须遵守** [代码验证规范](#二-代码验证规范-verification) 进行检查。
3.  **更新计划 (Update Plan)**：
    *   ✅ **若成功**：输出代码内容，并将该步骤标记为 `[x]`。
    *   ❌ **若失败**：保持 `[ ]`，报告错误日志，并尝试修复。
    *   **关键动作**：必须使用 `Write`/`Edit` 工具物理更新《实施规划文档》，确保完成状态被持久化保存。
4.  **循环输出**：
    *   **每完成一个步骤**，必须重新输出更新后的《实施规划文档》。
    *   **自动暂停**（可选）：如果任务风险较高，每步完成后询问“是否继续”。

**循环终止**：当所有 Checkbox 均为 `[x]` 时，进入[最终交付](#四-最终交付)。

---

## 二、 代码验证规范 (Verification)

**原则**：代码修改完成后，**严禁运行程序**，必须执行以下静态检查。
1.  **格式化 (Formatting)**:
    *   Go: `go fmt ./...`
    *   JS/TS: `prettier --write .`
    *   Python: `black .`
2.  **静态分析 (Linting)**:
    *   Go: `golangci-lint run ./...`
    *   JS/TS: `eslint .`
    *   其他: 使用项目配置的 lint 工具。
3.  **结果处理**:
    *   ❌ **Lint 报错**: **必须修复**（这是代码不可用的强信号）。
    *   ⚠️ **Lint 警告**: 评估后修复。
    *   ✅ **通过**: 视为当前步骤代码层面完成。
4. **回顾与反思**：回顾用户的要求，确保自己是否完成了用户的要求，是否有遗漏的点。如果没有完成或者有需要修复的地方，请继续从步骤一开始执行并修复

### 2.1 新增函数注释规范
为方便后续维护与审查，当 Agent 在任意语言中**新增函数或方法**时，必须在函数定义前紧跟一段注释，至少包含以下信息：
- **Function**: 函数名（与实际定义保持一致）。
- **Complexity**: (可选) 仅当函数逻辑复杂（如圈复杂度 > 5 或时间复杂度 > O(N)）时，强制要求标注（如 `O(N)`、`Cyclomatic=10` 等，给出简明说明）。

示例（Go 语言）：
```go
// Function: checkUserPermission
// Complexity: O(N), Cyclomatic=10 (complex validation logic)
func checkUserPermission(ctx context.Context, userID string, resourceID string) error {
    // 业务逻辑实现
    // ...
    return nil
}
```

### 2.2 代码风格与复杂度规范
为保证生成代码的可维护性与可读性，Agent 在编写或重构代码时，必须遵守以下复杂度与风格要求：
- **圈复杂度上限**：单个函数/方法的圈复杂度一般不得超过 **20**。若评估后确需超过该值，必须在注释的 **Complexity** 字段中明确说明原因，并优先考虑拆分函数。
- **优先拆解复杂逻辑**：当出现长分支、深层嵌套或多重循环时，应主动**提取子函数**，按职责拆解为更小、更单一职责的函数，而不是在一个函数中堆叠大量逻辑。
- **控制函数长度**：尽量避免超长函数，优先通过抽取公共逻辑、早返回（early return）、卫语句等方式降低函数长度和圈复杂度。
- **渐进式重构**：在修改现有高复杂度函数时，如条件允许，应结合本次需求进行**小步重构**（如切出局部计算函数、拆分处理分支），逐步将圈复杂度降到合理范围。

上述要求与 2.1 小节的注释规范配合使用：当新增或改动函数且复杂度较高时，应在注释中如实标注当前复杂度，并以“不超过 20 且逻辑清晰”为目标进行设计与实现。

### 2.3 性能与架构规范 (Performance & Architecture)
为保障系统稳定性，避免性能瓶颈，Agent 在编写代码时必须遵守以下规范：

- **严防流量放大 (No Traffic Amplification)**：
    - **避免循环调用**：**尽可能避免**在循环结构（`for`、`range`、`while`）内部直接进行 RPC 调用、数据库查询、外部 HTTP 请求或复杂计算。若业务逻辑强制要求且无批量接口可用，**必须在代码注释中显式说明原因**，并评估性能影响（如限制批处理大小）。
    - **批量优先原则**：涉及多条数据处理时，必须优先使用批量接口（Batch API，如 `MGet`、`BatchInsert`）。若无批量接口，应先收集参数，再通过并发（需控制并发度）或重构下游接口解决，杜绝串行 N+1 调用。
    - **缓存使用**：对于高频读取且变更不频繁的数据，应合理使用本地缓存或分布式缓存，减少对底层存储或下游服务的直接冲击。

---


## 三、 异常处理与回退

1.  **Lint 无法修复**：
    *   若遇到底层依赖冲突或无法解决的 Lint 错误。
    *   **停止操作**，在计划文档中将该步骤标记为 **[BLOCK]**，向用户报告。
2.  **计划变更**：
    *   执行中发现原计划不可行。
    *   **停止执行**，输出新的《实施规划文档》请求用户重新确认。

---

## 四、 最终交付

1.  **清理现场**:
    *   删除**真正的临时文件**（如 `.tmp`, `.bak` 等）。
    *   **🔴 严禁删除** `artifacts/design/` 和 `artifacts/plan/` 目录下的文档。它们是重要的项目资产，而非临时产物。
2.  **全量检查**: 运行一次全项目 Lint 确保无引入新问题。
3.  **结束标识**: 输出最终的全勾选计划表，并输出：
    > "🎉 任务执行完毕，所有步骤已验证通过！"
##
---

**更新日志 (2025-12-24)**:
- v2.2: 明确“文档先行”原则，拆分“需求分析与设计”与“实施规划”两个阶段，强制要求输出设计文档与实施规划文档。
- v2.1: 引入“计划确认 -> 逐步执行”工作流，增加《执行计划文档》作为强制中间件。
- v2.0: 确立“严禁运行，仅限 Lint”的核心原则。
